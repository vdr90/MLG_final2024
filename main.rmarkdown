---
title: An√°lisis de popularidad de canciones en el servicio de streamig Spotify
date: 2024-05-03
authors:
  - Garc√≠a Aguilar Luis Alberto
  - Sara Luz Valenzuela Camacho
  - Valeria
  - Iv√°n
format: html
execute:
  cache: true
---


# An√°lisis de popularidad de canciones en spotify

## Introducci√≥n

De acuerdo con wikipedia, en la plataforma de Spotify se tiene acceso a m√°s de 100 millones de canciones. Algunas canciones son m√°s populares que otras. Si definimos a la variable ùëå como un rating de popularidad con ùëå ‚àà [0, 100]. En general, entre m√°s reproducciones recientes tenga una una canci√≥n, su rating de popularidad ser√° mayor. 

Sabemos que la popularidad de una canci√≥n, no siempre es reflejo de su calidad, popularidad a largo plazo, o popularidad afuera de la audiencia de Spotify.
Adem√°s del artista hay otras caracter√≠sticas que hacen popular a una canci√≥n, como la ‚Äúvalencia‚Äù, que define que tan alegre suena una pieza.

Para el proyecto nos enfocaremos en entender:

**Falta mencionar el modelo lineal y modelo lineal con prioris informativas**
* ¬øCu√°l es la popularidad t√≠pica de una canci√≥n en Spotify?
* ¬øHasta donde influye el artista en la popularidad de la canci√≥n?
* Para un s√≥lo artista, ¬øc√≥mo var√≠a la popularidad de sus canciones?
* ¬øC√≥mo influye la valencia en la popularidad de una canci√≥n?

M√©todos:

Para nuestro proyecto planeamos hacer tres tipos de modelos:

* **Modelo con par√°metros homog√©neos:** Modelar la popularidad de las canciones sin tomar en cuenta el artista.
* **Modelo con par√°metros heterog√©neos:** Modelar la popularidad de las canciones tomando en cuenta a los artistas que las interpretan.
* **Modelo Jer√°rquico:** Una alternativa intermedia donde permitimos que la distribuci√≥n inicial sobre la popularidad pueda adaptarse a los datos. Y comparar sus distribuciones predictivas con los datos observados, para ver cu√°l modela mejor y porqu√©.
* **Modelo Jerarquico con DAG:** Haremos un DAG para agregar al modelo jer√°rquico la variable de valencia.

Las librer√≠as que utilizamos son las soguientes:


```{r message=FALSE, results="hide"}
library(rstan)
library(ggplot2)
library(gridExtra)
library(tidyverse)
library(cmdstanr)
library(rsample)
```


## Datos

[una descripci√≥n de los datos que se usan para el modelo, ya sean datos observados o simulados y el contexto en el que se utilizan.]

Observamos la estructura de los datos


```{r}
datos <- read.csv("datos/datos.csv") 
datos <- as.data.frame(datos)
selected_datos_small <- read.csv("datos/datos_small.csv") 
glimpse(datos)
```


Contamos con 114000 registros de canciones y 21 caracter√≠sticas que los representan. Sin embargo vamos a ocupar s√≥lo una muestra de 57,000 canciones. En el Anexo 1 de este trabajo se encuentra la limpieza y adecuaci√≥n de datos para su uso en la modelaci√≥n de la popularidad de las canciones.


```{r}
datos <- read.csv("datos/muestra.csv") 
```


Obtenemos un resumen de los datos y sus variables

```{r}
print(summary(datos))
```


# M√©todos

## Modelo lineal

Generamos un modelo lineal con priors poco informativas.

El modelo lineal simple lo expresamos como:

$y_i=\beta_0 + \beta_1 * x_i + \sigma_i‚Äã$

Donde:

  $y_i$‚Äã es la popularidad de la observaci√≥n i.
  $x_i$‚Äã es la variable predictora (por ejemplo, duraci√≥n de la canci√≥n) para la observaci√≥n i.
  $\beta_0$‚Äã y $\beta_1$‚Äã son los coeficientes del modelo.
  $\sigma_i$‚Äã es el error aleatorio asociado con la observaci√≥n i, que asumiremos normalmente distribuido con media cero y varianza constante.
  
**ojo se mencionan dos betas pero son 5 betas en el modelo**


```{r}

stan_code_lineal <- "
data {
  int<lower=0> N;  
  int<lower=0, upper=100> popularity[N];    
  real<lower=0> duration[N];      
  int<lower=0, upper=1> explicito[N];
  real<lower=0, upper=1> dance[N];  
  real<lower=0, upper=244> tempo[N];     
  int<lower=1, upper=114> genre[N];     
}
parameters {
  real mu_popularity; 
  real<lower=0> sigma_popularity;                            
  real beta_duration;
  real beta_explicito;
  real beta_dance;
  real beta_tempo;
  real beta_genre;                             
}
model {
  // Priors
  mu_popularity ~ normal(0,1);        
  sigma_popularity ~ normal(0,1);         
  beta_duration ~ normal(0,1);        
  beta_explicito ~ normal(0,1);        
  beta_dance ~ normal(0,1);   
  beta_tempo ~ normal(0,1);        
  beta_genre ~ normal(0,1);        
     

  // Likelihood
  for (i in 1:N) {
    popularity[i] ~ normal(mu_popularity + 
                            beta_duration * duration[i] +
                            beta_explicito * explicito[i] +
                            beta_dance * dance[i] +
                            beta_tempo * tempo[i] +
                            beta_genre * genre[i] 
                            , sigma_popularity); 
  }
}
"

# Compilar el modelo
stan_model_lineal <- stan_model(model_code = stan_code_lineal)


```

```{r message= FALSE, results="hide"}

# Ajustar el modelo a los datos
fit_lineal <- sampling(stan_model_lineal, 
                       data = list(N = nrow(selected_datos_small), 
                                   popularity = selected_datos_small$popularity,
                                   duration = selected_datos_small$duration_ms,
                                   explicito = selected_datos_small$explicit,
                                   dance = selected_datos_small$danceability,
                                   tempo = selected_datos_small$tempo,
                                   genre = selected_datos_small$genre_numeric), 
                       iter=10000, warmup=3000, seed=123)

```

```{r}

# Ver resultados
print(fit_lineal)

```


Observamos intervalos de credibilidad


```{r}

extract_lineal <- rstan::extract(fit_lineal, permuted = TRUE)


stan_plot(fit_lineal, prob = 0.95)

```


Podemos ver tambien, al observar los coeficientes, que el g√©nero y el grado de "daceability" tienen una mayor influencia sobre la popularidad de una canci√≥n.

## Modelo lineal con prioris informativas

Modelamos la opularidad en base a las siguientes caracter√≠sticas:

  * Duraci√≥n: duration_ms
  * ¬øEs explicita?: explicit
  * ¬øQue tan bailable?: danceability
  * Tempo: tempo
  * Genero: track_genre

Proponemos como distribuciones iniciales las siguientes:

  * Popularidad:
    
    Es nuestra variable objetivo y debido a que la popularidad es un valor discreto entre 0 y 100, elegimos una distribuci√≥n Binomial Negativa la cual permitir√° modelar la sobredispersi√≥n, pues esperamos que la popularidad tenga una amplia variabilidad.

    En este caso, consideramos la popularidad como el resultado de un proceso de "√©xito", es decir, la canci√≥n es escuchada o marcada como favorita por un usuario hasta que se alcanza un n√∫mero fijo de "√©xitos" ( cierto nivel de popularidad).

    * popularidad ~ N($\mu$,$\phi$)
  
  * Duraci√≥n:
  
    Sabemos que la duraci√≥n de las canciones debe ser mayor a cero y tiene una media aproximada de 3 minutos, por lo que usaremos una distribuci√≥n exponencial.

    * duraci√≥n ~ Exp($\lambda$) ; $\lambda$ = 1/180000 (se encuentra en milisegundos)

  * Explicita: 
  
    La bariable "explicita" es una variable que tomar√° los valores 0 y 1. Usaremos entonces una distribuci√≥n Beta para modelarla.

    * explicita ~ Beta($\rho$) 

  * Bailable:

    Ya que los valores que toma esta variable se encuentran entre 0 y 1, utilizaremos uns distribuci√≥n Beta.

    * bailable ~ Beta($\alpha$,$\beta$)

  * Tempo:

    Variable continua entre 0 y 244. Utilizaremos una distribuci√≥n normal truncada

    * tempo ~ N+($\mu$,$\sigma$)

  * Genero:

    El genero es una variable entera, por lo que la modelaremos usando una distribuci√≥n Multinomial.

    * genero ~ Multinomial(n,p)

 Utilizaremos un modelo lineal generalizado (GLM) donde la popularidad sea una funci√≥n lineal de las dem√°s variables, teniendo en cuenta la naturaleza discreta de la popularidad (valores enteros entre 0 y 100).


```{r}

  stan_code <- "
  data {
    int<lower=0> N;               
    int<lower=0, upper=100> popularity[N];  
    real<lower=0> duration_ms[N];      
    int<lower=0, upper=1> explicito[N];
    real<lower=0, upper=1> danceability[N];  
    real<lower=0, upper=244> tempo[N];     
    real<lower=1, upper=114> genre[N];        
  }

  parameters {
    real phi_popularity;
    real<lower=0> p_duration;        
    real<lower=0, upper=1> p_explicit;  
    real<lower=0, upper=1> p_dance; 
    real<lower=0> mu_tempo;             
    real<lower=0> sigma_tempo;  
    real<lower=0> mu_genre;             
    real<lower=0> sigma_genre;        
    real<lower=0> p_tempo;                
    real<lower=0> p_genre;              

  }

  model {

    // Priors
    phi_popularity ~ normal(0, 1);
    p_duration ~ exponential(180000);  
    p_explicit ~ beta(2,2);                
    p_dance ~ beta(1, 1);           
    mu_tempo ~ normal(120, 30);               
    sigma_tempo ~ cauchy(0, 5);      
    mu_genre ~ normal(120, 30);               
    sigma_genre ~ cauchy(0, 5);  
    p_tempo ~ normal(mu_tempo, sigma_tempo);
    p_genre ~ normal(mu_genre, sigma_genre);

    // Likelihood
    for (i in 1:N) {
      real mu_popularity;
      
      mu_popularity = p_duration * duration_ms[i] + 
                      p_explicit * explicito[i] +
                      p_dance * danceability[i] +
                      p_tempo * tempo[i] +
                      p_genre * genre[i];
      
      popularity[i] ~ neg_binomial_2(mu_popularity, phi_popularity); // Distribuci√≥n binomial negativa para popularidad
    }
  }
  "


# Compilar el modelo
stan_model <- stan_model(model_code = stan_code)


```

```{r message= FALSE, results="hide"}

stan_data <- list(
  N = nrow(selected_datos_small),
  popularity = selected_datos_small$popularity,
  duration_ms = selected_datos_small$duration_ms,
  explicito = selected_datos_small$explicit,
  danceability = selected_datos_small$danceability,
  tempo = selected_datos_small$tempo,
  genre = selected_datos_small$genre_numeric
)


# Ajustar el modelo a los datos
fit <- sampling(stan_model, data = stan_data, chains = 4, iter = 50000, warmup = 5000, seed=123)

```

```{r}

# resultados
print(fit)

```


Observamos intervalos de credibilidad


```{r}

stan_plot(fit, prob = 0.95)

```


Notamos que entre los coeficientes m√°s altos se encuentran: genero, "danceability" y "explicit".


## Modelo de popularidad individual

El siguente modelo considerar√° solo la popularidad del artista como predictor de la popularidad de la canci√≥n.


```{r}

individual_code <-"
data {
  int<lower=0> N;                
  vector[N] popularity_artist;   
  vector[N] popularity;     
}

parameters {
  real intercept;                 
  real beta_artist;               
  real<lower=0> sigma;            
}

model {
  // Priors
  intercept ~ normal(0, 1);      
  beta_artist ~ normal(0, 1);     
  sigma ~ normal(0, 1);           

  // Likelihood
  for (i in 1:N) {
    // Modelo lineal
    popularity[i] ~ normal(intercept + beta_artist * popularity_artist[i], sigma);
  }
}
"


# Compilar el modelo
individual_model <- stan_model(model_code = individual_code)

```

```{r message= FALSE, results="hide"}

stan_indiv_data <- list(
  N = nrow(selected_datos),
  popularity = selected_datos$popularity,
  popularity_artist = selected_datos$popularity_artist
)


# Ajustar el modelo a los datos
individual_fit <- sampling(individual_model, data = stan_indiv_data, chains = 4, iter = 10000, warmup = 500)

```

```{r}

print(individual_fit)

```

```{r}

stan_plot(individual_fit, prob = 0.95)

```



Para observar el desempe√±o obtendremos las estimaciones de popularidad para 20 canciones y compararemos estas con la popularidad real.

En el siguiente gr√°fico puede observarse un intervalod el 95% de credibilidad para las 10 canciones as√≠ como la media de las simulaciones y el valor real de la popularidad para la canci√≥n.


```{r}
avg_popularity_artists <- mean(selected_datos$popularity_artist)

n_songs = 20
# Calculamos las predicciones con los coeficientes obtenidos
comp_simul <- list()

for (i in 1:n_songs) {
  mu_pred <- mean(rstan::extract(individual_fit)$intercept) + 
             mean(rstan::extract(individual_fit)$beta_artist) * avg_popularity_artists
             
  pred_simuladas <- rnorm(10000, mean = mu_pred, sd = mean(rstan::extract(individual_fit)$sigma))

  comp_simul[[i]] <- list(real_popularity = datos$popularity[i], simulated_popularity = pred_simuladas)
}

```

```{r}

# Establecer m√°rgenes m√°s peque√±os
par(mar = c(2, 2, 2, 2))

par(mfrow=c(5, 4))  

for (i in 1:length(comp_simul)) {

  real_popularity <- comp_simul[[i]]$real_popularity
  simulated_popularity <- comp_simul[[i]]$simulated_popularity
  
  # intervalo de confianza del 95%
  ci <- quantile(simulated_popularity, c(0.025, 0.975))
  

  plot(1, xlim=c(0, 2), ylim=c(0, max(c(real_popularity, ci))), type="n", xlab="", ylab="Popularidad")
  lines(rep(1, 2), ci, col="darkcyan", lwd=2)  
  points(1, abs(mean(simulated_popularity)), col="brown", pch=19)  
  points(1, real_popularity, col="orange", pch=19)  
  text(1.05, real_popularity, paste("Real:", real_popularity), pos=4,offset=1)  # Etiqueta valor real
  text(1.05, mean(simulated_popularity), paste("Media:", round(abs(mean(simulated_popularity)), 2)), pos=4,offset=-6)  # Etiqueta  media
  title(paste("Canci√≥n", i))  # T√≠tulo
}

par(mfrow=c(1, 1)) 

par(mar = c(5, 4, 4, 2) + 0.1)


```



## Modelo popularidad entre artistas


```{r}

general_stan_code <-" 
data {
  int<lower=0> N;                // N√∫mero de observaciones
  real popularity_avg_artist;    // Popularidad promedio entre artistas
  vector[N] popularity;          // Popularidad de la canci√≥n
}

parameters {
  real intercept;                // Intercepto
  real beta_artist;              // Coeficiente de la popularidad entre artistas
  real<lower=0> sigma;           // Desviaci√≥n est√°ndar de los errores
}

model {
  // Priors
  intercept ~ normal(0, 1);      // Prior para el intercepto
  beta_artist ~ normal(0, 1);     // Prior para el coeficiente de la popularidad entre artistas
  sigma ~ normal(0, 1);           // Prior para la desviaci√≥n est√°ndar

  // Likelihood
  for (i in 1:N) {
    // Modelo lineal
    popularity[i] ~ normal(intercept + beta_artist * popularity_avg_artist, sigma);
  }
}

//generated quantities {
//  vector[N] simulated_popularity;  // Simulaciones de la popularidad de las canciones

  // Generar simulaciones
//  for (i in 1:N) {
//    simulated_popularity[i] = normal_rng(intercept + beta_artist * popularity_avg_artist, sigma);
//  }
//}
"


# Compilar el modelo
general_model <- stan_model(model_code = general_stan_code)

```

```{r message= FALSE, results="hide"}

avg_popularity_artists <- mean(selected_datos$popularity_artist)

stan_general_data <- list(
  N = nrow(selected_datos),
  popularity = selected_datos$popularity,
  popularity_avg_artist = avg_popularity_artists
)


# Ajustar el modelo a los datos
general_fit <- sampling(general_model, data = stan_general_data, chains = 4, iter = 10000, warmup = 500, seed=123)

```

```{r}

print(general_fit)

```

```{r}

stan_plot(general_fit, prob = 0.95)

```



Para observar el desempe√±o obtendremos las estimaciones de popularidad para 20 canciones y compararemos estas con la popularidad real.

En el siguiente gr√°fico puede observarse un intervalod el 95% de credibilidad para las 10 canciones as√≠ como la media de las simulaciones y el valor real de la popularidad para la canci√≥n.


```{r}

n_songs = 20
comp_simul <- list()

for (i in 1:n_songs) {
  mu_pred <- mean(rstan::extract(general_fit)$intercept) + 
             mean(rstan::extract(general_fit)$beta_artist) * avg_popularity_artists
             
  pred_simuladas <- rnorm(10000, mean = mu_pred, sd = mean(rstan::extract(general_fit)$sigma))

  comp_simul[[i]] <- list(real_popularity = datos$popularity[i], simulated_popularity = pred_simuladas)
}

```

```{r}
par(mar = c(2, 2, 2, 2))


par(mfrow=c(5, 4))  

for (i in 1:length(comp_simul)) {

  real_popularity <- comp_simul[[i]]$real_popularity
  simulated_popularity <- comp_simul[[i]]$simulated_popularity
  
  # intervalo de confianza del 95%
  ci <- quantile(simulated_popularity, c(0.025, 0.975))
  

  plot(1, xlim=c(0, 2), ylim=c(0, max(c(real_popularity, ci))), type="n", xlab="", ylab="Popularidad")
  lines(rep(1, 2), ci, col="darkcyan", lwd=2)  
  points(1, abs(mean(simulated_popularity)), col="brown", pch=19)  
  points(1, real_popularity, col="orange", pch=19)  
  text(1.05, real_popularity, paste("Real:", real_popularity), pos=4,offset=1)  # Etiqueta valor real
  text(1.05, mean(simulated_popularity), paste("Media:", round(abs(mean(simulated_popularity)), 2)), pos=4,offset=-6)  # Etiqueta  media
  title(paste("Canci√≥n", i))  # T√≠tulo
}

par(mfrow=c(1, 1)) 

par(mar = c(5, 4, 4, 2) + 0.1)

```




## Modelo jer√°rquico


```{r}

jerarquico_code <- "
data {
  int<lower=0> N;                     // N√∫mero de observaciones
  vector[N] popularity_artist;        // Popularidad individual del artista
  real popularity_avg_artist;         // Popularidad promedio entre artistas
  vector[N] popularity;               // Popularidad de la canci√≥n
}

parameters {
  real intercept;                     // Intercepto
  real beta_individual_artist;        // Coeficiente de la popularidad individual del artista
  real beta_avg_artist;               // Coeficiente de la popularidad promedio entre artistas
  real<lower=0> sigma;                // Desviaci√≥n est√°ndar de los errores
}

model {
  // Priors
  intercept ~ normal(0, 1);          // Prior para el intercepto
  beta_individual_artist ~ normal(0, 1);  // Prior para el coeficiente de la popularidad individual del artista
  beta_avg_artist ~ normal(0, 1);     // Prior para el coeficiente de la popularidad promedio entre artistas
  sigma ~ normal(0, 1);               // Prior para la desviaci√≥n est√°ndar

  // Likelihood
  for (i in 1:N) {
    // Modelo lineal jer√°rquico
    popularity[i] ~ normal(intercept + beta_individual_artist * popularity_artist[i] + beta_avg_artist * popularity_avg_artist, sigma);
  }
}

"

# Compilar el modelo
jerarquico_model <- stan_model(model_code = jerarquico_code)

```


Ejecutamos el modelo


```{r message= FALSE, results="hide"}

stan_jerarquico_data <- list(
  N = nrow(selected_datos),
  popularity = selected_datos$popularity,
  popularity_avg_artist = avg_popularity_artists,
  popularity_artist = selected_datos$popularity_artist
)


# Ajustar el modelo a los datos
jerarquico_fit <- sampling(jerarquico_model, data = stan_jerarquico_data, chains = 4, iter = 10000, warmup = 500)

print(jerarquico_fit)

```


Observamos el resumen del entrenamiento


```{r}

stan_plot(jerarquico_fit, prob = 0.95)

```


Para observar el desempe√±o obtendremos las estimaciones de popularidad para 20 canciones y compararemos estas con la popularidad real.

En el siguiente gr√°fico puede observarse un intervalod el 95% de credibilidad para las 10 canciones as√≠ como la media de las simulaciones y el valor real de la popularidad para la canci√≥n.


```{r}

n_songs = 20
# Calculamos las predicciones con los coeficientes obtenidos
comp_simul <- list()

for (i in 1:n_songs) {
  mu_pred <- mean(rstan::extract(jerarquico_fit)$intercept) + 
             mean(rstan::extract(jerarquico_fit)$beta_individual_artist) * datos$popularity_artist[i] +
             mean(rstan::extract(jerarquico_fit)$beta_avg_artist) * avg_popularity_artists
             
  pred_simuladas <- rnorm(10000, mean = mu_pred, sd = mean(rstan::extract(jerarquico_fit)$sigma))

  comp_simul[[i]] <- list(real_popularity = datos$popularity[i], simulated_popularity = pred_simuladas)
}

```

```{r}

par(mar = c(2, 2, 2, 2))


par(mfrow=c(5, 4))  

for (i in 1:length(comp_simul)) {

  real_popularity <- comp_simul[[i]]$real_popularity
  simulated_popularity <- comp_simul[[i]]$simulated_popularity
  
  # intervalo de confianza del 95%
  ci <- quantile(simulated_popularity, c(0.025, 0.975))
  

  plot(1, xlim=c(0, 2), ylim=c(0, max(c(real_popularity, ci))), type="n", xlab="", ylab="Popularidad")
  lines(rep(1, 2), ci, col="darkcyan", lwd=2)  
  points(1, abs(mean(simulated_popularity)), col="brown", pch=19)  
  points(1, real_popularity, col="orange", pch=19)  
  text(1.05, real_popularity, paste("Real:", real_popularity), pos=4,offset=1)  # Etiqueta valor real
  text(1.05, mean(simulated_popularity), paste("Media:", round(abs(mean(simulated_popularity)), 2)), pos=4,offset=-6)  # Etiqueta  media
  title(paste("Canci√≥n", i))  # T√≠tulo
}

par(mfrow=c(1, 1)) 

par(mar = c(5, 4, 4, 2) + 0.1)

```


# Resultados
[La aplicaci√≥n de los m√©todos a los datos. Los resultados deben ser presentados en forma f√°cil de entender, a trav√©s de gr√°ficas, tablas de resumen de los resultados. En todos los casos, las gr√°ficas y tablas tienen que ser relevantes para la comunicaci√≥n de los resultados, no tienen que ser redundantes, y tienen que ser correctas.]

# Conclusiones

[un resumen de la conclusi√≥n del estudio, en donde se especif√≠que c√≥mo se resolvi√≥ el problema propuesto, as√≠ como futuras v√≠as de ampliaci√≥n del estudio. Tambi√©n mencionar las limitaciones que se encontraron, y porqu√© no se pudieron atacar algunos aspectos originales del problema.]

# Fuentes

[fuentes bibliogr√°ficas utilizadas.]

# Anexos

[en caso de que sea necesario hacer tablas o resultados extensivos, ser√° conveniente ponerlos en un anexo. No se aceptar√°n salidas extensas como parte principal del reporte.]


